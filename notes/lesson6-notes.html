<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>6-Lesson Notes</title>
<!--
   Andrew Kim
   6 - Lesson Notes
   10/7/24
-->
</head>
<body>

<header>
    <h1> Lesson 6 Notes </h1>
    <h2>Lesson 12: Creating Layouts Using Modern CSS Techniques</h2>


</header>

<ol>
    <li>How fixed layouts work</li>
    <li>How liquid layouts work</li>
    <li>How to create a fixed/liquid hybrid layout</li>
    <li>How to create CSS flexible box layouts</li>
    <li>How to use CSS grid layouts</li>
</ol>

    <h2>Summary for Lesson 12</h2>
    <p>There are 2 basic types of layouts: fixed and liquid. In order to master page layout we need a good understanding of the CSS box model and 
        have a professive enhancement mentality when creating web sites. You need to keep in mind that in today's day and age, we must design 
        for mobile devices. 
 </p>

 <p>Having a Fixed Layout is setting up the body of the page to have a specific width. Designers would implement this because they want to have a 
    precise control over the appearance of the content area. The problem with this is that it is not dynamic and will cause problems with devices that
    are much larger or smaller in screen size. A Liquid Layout in the other hand is more dynamic. It can be usable and still retains the overall 
    design aesthetic even if the user has a very small or large screen.
 </p>

<p>3 most commonly used CSS layout:</p>
    <ul>
        <li>CSS table—CSS properties that change the display of page elements to tables, table rows, and table columns.</li>
        <li>CSS flexible box layout—CSS properties that make it easier to lay out, align, and distribute space among elements in a container.</li>
        <li>CSS grid layout—A grid-based layout system with rows and columns.</li>
    </ul>
 <p>There are several table options on the display property:</p>
 <ul>
    <li>table — Behaves like a &lt;table&gt; element</li>
    <li>inline-table — Behaves like a &lt;table&gt; element that is rendered inline</li>
    <li>table-row — Behaves like a table row (&lt;tr&gt;) element</li>
    <li>table-cell — Behaves like a table cell (&lt;td&gt;) element</li>
    <li>table-column — Behaves like a &lt;col&gt; element</li>
    <li>table-caption — Behaves like a &lt;caption&gt; element</li>
    <li>table-row-group — Behaves like a &lt;tbody&gt; element</li>
    <li>table-header-group — Behaves like a &lt;thead&gt; element</li>
    <li>table-footer-group — Behaves like a &lt;tfoot&gt; element</li>
    <li>table-column-group — Behaves like a &lt;colgroup&gt; element</li>
  </ul>

  <p>To build a felxible box container, you can utilize the display: felx property. You then determine what direction the elements in the 
    container are going to flow. You use the flex-direction property with these 4 choices of values: 
  </p>
  <ul>
    <li>row — The flex items flow left to right in LTR (left-to-right) layouts and right to left in RTL (right-to-left) layouts. This is the default.</li>
    <li>row-reverse — The items flow right to left in LTR layouts and left to right in RTL layouts. This is the opposite of row.</li>
    <li>column — Items flow from top to bottom in a column.</li>
    <li>column-reverse — Items flow from bottom to top in a column. This is the opposite of column.</li>
  </ul>
  
<p>Then you define how the items will wrap when they come up to the boundary with the flex-wrap property.  </p>

<ul>
    <li>nowrap — All flex items are on one line (horizontal or vertical). This is the default.</li>
    <li>wrap — Flex items wrap to multiple lines from top to bottom.</li>
    <li>wrap-reverse — Flex items wrap to multiple lines from bottom to top. This is the opposite of wrap.</li>
  </ul>
  
  <p>Most web pages are built using some form of grid. To use the CSS Grid Layout system, you define a container element as display: grid; and then 
    define your columns and rows with the grid-template-columns and grid-template-rows properties. Once you have defined the grid, you place the 
    child elements into the grid with grid-template-areas and the grid-area property. 
</p>

    <h2>Lesson 13: Taking Control of Backgrounds and Borders</h2>
    
    <ul>
        <li>How to layer backgrounds</li>
        <li>How to use gradients as backgrounds</li>
        <li>How to use CSS properties to create “zebra-stripe” tables automatically</li>
        <li>How to create rounded corners on elements</li>
        <li>How to use images as borders</li>
        <li>How outlines are different from borders</li>
    </ul>

    <h2>Summary for Lesson 13</h2>
    <p>So far we only discussed changing the color of a background. However, there are many different uses for the background property. Here are some other use cases: </p>
    <ul>
        <li>background-image — The image used as a background.</li>
        <li>background-position — Where the image should be placed on the element, written as a length, a percentage, or a keyword (top, bottom, center, right, and left).</li>
        <li>background-size — The size of the image in the element, either as the width, the width and height, or a keyword (cover or contain).</li>
        <li>background-repeat — Whether and how the image should tile in the element, using one of the values repeat, repeat-x, repeat-y, no-repeat, space, or round.</li>
        <li>background-origin — Where the background image should start tiling; possible values are border-box, padding-box, and content-box.</li>
        <li>background-clip — How the background should display beyond the element’s content or padding; possible values are border-box, padding-box, or content-box.</li>
        <li>background-attachment — How the background should move relative to the viewport; possible values are scroll, fixed, or local.</li>
        <li>background-color — The color of the background, using a color keyword or color code.</li>
      </ul>
      <p>Background-clip propert allows you to change what parts of the box the background covers. You can ulitze border-box, padding-box, or content-box. Another interesting
        use of background is the use of gradients. You can use the linear gradient with background-image:linear-gradient( #ff00d5, rgba(39, 164, 0, 0.5), blue ); We can utilize 
        images as borders with border-image-source. From here we can decide to stretch, repeat, round, or space the images to fill in our border. 
      </p> 
      

    <h2>Lesson 14: Using CSS Transformations and Transitions</h2>
    <ul>
        <li>How to transform elements by rotating, scaling, moving, and tilting</li>
        <li>How to work with transformations in three dimensions</li>
        <li>How to apply multiple transformations to one element</li>
        <li>How to do simple animations with the transition property</li>
      </ul>
      
    <h2>Summary for Lesson 14</h2>
    <p>The most commonly used transformation fucntions are rotate, scale, translate, and skew. You can utilize transfrom: translate(horizontal, vertical); to mvoe elements.
        For example, transform: translate(50px,20px); will move an element 50 pixels to the right and 20 pixels down from where it normally would display on the page. Another 
        important thing to remember is that you can utilize more than one transformations on the same element. 
    </p>

    <p>Working with transitions is similar to transformations. You can utilzie different timings of the transitions with ease, ease-in, ease-out, ease-in-out., and linear. 
      Additionally, you can control when these transitions occur with JavaScript. 
    </p>

    <ul>
      <li>transition-property — Indicates which CSS properties should transition.</li>
      <li>transition-duration — Defines the amount of time the transition will take.</li>
      <li>transition-timing-function — Specifies the function used to determine how intermediate values in the animation are computed.</li>
      <li>transition-delay — Defines when the transition will start.</li>
    </ul>
    



    <h2>Lesson 15: Animating with CSS and the Canvas</h2>
    <ul>
        <li>How to generate a CSS animation</li>
        <li>How CSS animations are different from transitions and how they are similar</li>
        <li>Creating keyframes to hold and control animations</li>
        <li>Using the HTML5 &lt;canvas&gt; element for self-contained animations</li>
      </ul>
      
    <h2>Summary for Lesson 15</h2>
    <p>There are 8 animation properties:</p>

    <ul>
      <li>animation-delay—Specifies the delay between when the element is loaded and when the animation starts.</li>
      <li>animation-direction—Determines whether the animation should alternate direction on each sequence or start at the beginning.</li>
      <li>animation-duration—Sets the length of time to complete one cycle of the animation.</li>
      <li>animation-iteration-count—Configures the number of times the animation should repeat. The keyword infinite says the animation should repeat forever.</li>
      <li>animation-name—Defines the name of the @keyframes rule to use in the animation.</li>
      <li>animation-play-state—Allows the animation to be paused and resumed.</li>
      <li>animation-timing-function—Defines the acceleration curves for the animation to transition through the keyframes.</li>
      <li>animation-fill-mode—Defines the values applied to the animation before and after it executes.</li>
    </ul>

    <p>We can utilize these properties by setting up @keyframes. You start off with a from{...} clause and end with to{...}
      The HTML canvas element allows for dynamic drawing and animation using JavaScript. To use it, you first define a <canvas> element with specified width and height, and optionally assign it an ID. CSS can add a border for visibility.
        To draw on the canvas, you retrieve the drawing context with getContext('2d'). You can draw various shapes—like rectangles and circles—using methods such as fillRect(), strokeRect(), and arc(). Shapes can be styled with fillStyle 
        and strokeStyle. You can also draw lines and polygons using path methods like beginPath(), moveTo(), and lineTo(). For images, you load them via JavaScript and use drawImage() to display them on the canvas.For animation, you can create 
        sprite animations by cropping sections of a composite image and using setInterval() to update the canvas at intervals. The clearRect() method clears the canvas before each frame is drawn.
    </p>

    



    
</body>
</html>

